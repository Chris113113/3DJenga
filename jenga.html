<!DOCTYPE html>

<html>

<head>
    <title>Jenga - Physijs</title>
    
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap-theme.css" />
    
    <script type="text/javascript" src="libs/jquery-1.11.3.js"></script>
    <script type="text/javascript" src="libs/bootstrap.js"></script>
    <script type="text/javascript" src="libs/three.min.js"></script>
    <script type="text/javascript" src="libs/stats.min.js"></script>
    <script type="text/javascript" src="libs/physi.js"></script>
    <script type="text/javascript" src="libs/TrackballControls.js"></script>
    <script type="text/javascript" src="libs/threex.keyboardstate.js"></script>

    <script type="text/javascript">
    
    'use strict';
    
    Physijs.scripts.worker = 'libs/physijs_worker.js';
    Physijs.scripts.ammo = 'ammo.js';
    
    var initScene, initEventHandling, render, createTower, loader,
        renderer, render_stats, physics_stats, scene, dir_light, am_light, camera,
        table, blocks = [], table_material, block_material, intersect_plane,
        selected_block = null, mouse_position = new THREE.Vector3, block_offset = new THREE.Vector3, _i, _v3 = new THREE.Vector3;

    var controls, keyboard, radius = 25, clock, xrotation = 0, yposition = 20, clockReset = 0, myWorker, skyboxMesh, ai = true, curMaxHeight, curRotOrder, curState = 'play';
    
    initScene = function() {

        triggerModal();

        keyboard = new THREEx.KeyboardState();
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById( 'viewport' ).appendChild( renderer.domElement );
        
        render_stats = new Stats();
        render_stats.domElement.style.position = 'absolute';
        render_stats.domElement.style.top = '1px';
        render_stats.domElement.style.zIndex = 100;
        //document.getElementById( 'viewport' ).appendChild( render_stats.domElement );
        physics_stats = new Stats();
        physics_stats.domElement.style.position = 'absolute';
        physics_stats.domElement.style.top = '50px';
        physics_stats.domElement.style.zIndex = 100;
        //document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );
        
        scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
        scene.setGravity(new THREE.Vector3( 0, -10, 0 ));
        scene.addEventListener(
            'update',
            function() {
                if ( selected_block !== null ) {
                    
                    _v3.copy( mouse_position ).add( block_offset ).sub( selected_block.position ).multiplyScalar( 5 );
                    _v3.y = 0;
                    selected_block.setLinearVelocity( _v3 );
                    
                    // Reactivate all of the blocks
                    _v3.set( 0, 0, 0 );
                    for ( _i = 0; _i < blocks.length; _i++ ) {
                        blocks[_i].applyCentralImpulse( _v3 );
                    }
                }
                scene.simulate( undefined, 1 );
                physics_stats.update();
            }
        );
        
        camera = new THREE.PerspectiveCamera(
            35,
            window.innerWidth / window.innerHeight,
            1,
            1000
        );
        camera.position.set( radius, radius, radius );
        camera.lookAt(new THREE.Vector3( 0, 7, 0 ));
        scene.add( camera );

        controls = new THREE.TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;

        controls.noZoom = false;
        controls.noPan = false;

        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        controls.keys = [ 65, 83, 68 ];

        controls.addEventListener( 'change', render );
        
        // ambient light
        am_light = new THREE.AmbientLight( 0x444444 );
        scene.add( am_light );
        // directional light
        dir_light = new THREE.DirectionalLight( 0xFFFFFF );
        dir_light.position.set( 20, 30, -5 );
        dir_light.target.position.copy( scene.position );
        dir_light.castShadow = true;
        dir_light.shadowCameraLeft = -30;
        dir_light.shadowCameraTop = -30;
        dir_light.shadowCameraRight = 30;
        dir_light.shadowCameraBottom = 30;
        dir_light.shadowCameraNear = 20;
        dir_light.shadowCameraFar = 200;
        dir_light.shadowBias = -.001
        dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
        dir_light.shadowDarkness = .5;
        scene.add( dir_light );

        clock = new THREE.Clock();
        clock.autoStart = true;

        // Loader
        loader = new THREE.TextureLoader();
        
        // Materials
        table_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/woodFloor.jpg' )}),
            .9, // high friction
            .2 // low restitution
        );
        table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;

        table_material.map.repeat.set( 1, 1 );
        
        block_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/woodBlock.jpg' )})
        );
        block_material.map.wrapS = block_material.map.wrapT = THREE.RepeatWrapping;
        block_material.map.repeat.set( 1, .5 );
        
        // Table
        table = new Physijs.BoxMesh(
            new THREE.BoxGeometry(50, 1, 50),
            table_material,
            0, // mass
            { restitution: .2, friction: .9 }
        );
        table.name = 'table';
        table.position.y = -.5;
        table.receiveShadow = true;
        scene.add( table );
        
        createTower();
        GenerateSkybox();

        myWorker = new Worker("scripts/myWorker.js");
        myWorker.onmessage = onmessageHandler;
        
        intersect_plane = new THREE.Mesh(
            new THREE.PlaneGeometry( 150, 150 ),
            new THREE.MeshBasicMaterial({ opacity: 0, transparent: true })
        );
        intersect_plane.rotation.x = Math.PI / -2;
        scene.add( intersect_plane );
        initEventHandling();
        
        requestAnimationFrame( render );
        scene.simulate();
    };
    
    render = function() {
        if(!clock.running) {
            clock.start();
        }
        getNewRotation();
        requestAnimationFrame( render );
        renderer.render( scene, camera );
        render_stats.update();
        removeObjects();
    };

    function triggerModal() {
        $("#myModal").modal()//{keyboard:false, show:true});
    }

    function aiturn() {
        if(curState == 'play'){

            var btb = blocks[Math.floor(Math.random() * blocks.length)];
            
            if(btb.rotOrder != 0) {
                btb.applyCentralImpulse(new THREE.Vector3(2000, 0, 0));
            }
            else {
                btb.applyCentralImpulse(new THREE.Vector3(0, 0, 2000));
            }
        }
    }

    function removeObjects() {
        for(var i = blocks.length-1; i >= 0; i--) {
            if(blocks[i].position.x > 5 || blocks[i].position.x < -5 || blocks[i].position.z > 5 || blocks[i].position.z < -5) {
                if(blocks[i].position.y < 3) {
                    if(curState == 'play'){
                        scene.remove(blocks[i]);
                        blocks.splice(i, 1);

                        //Game Over check
                        
                        if(clock.getElapsedTime() - clockReset < 1) {
                            myWorker.postMessage(['gameover']);
                            console.log('Game Over');
                        } else {
                            clockReset = clock.getElapsedTime();
                            myWorker.postMessage(['score']);
                        }
                    }
                }
            }
        }
    }

    //[CUR_PLAYER, SCORE['',P1,P2], ADDLAYERBOOLEAN, GAMEOVERBOOLEAN]

    var onmessageHandler = function(e) {
        $("#p1score").text("Player 1: " + e.data[1][1]);
        $("#p2score").text("Player 2: " + e.data[1][2]);
        $("#curplayer").text("Player " + e.data[0] + "'s turn");
        if(ai && e.data[0] == 2 && !e.data[3]) {
            window.setTimeout(aiturn, 1000);
        }
        if(!e.data[3] && e.data[2]) {
            addLayerToTower();
        }
        if(e.data[3]) {
            $("#gameover").text("GAME OVER");
            $("#curplayer").text("Player " + e.data[0] + " Wins!");
            curState = 'gameover';
        }
    }

    function GenerateSkybox() {
         var materials = [
           new THREE.MeshLambertMaterial({
               map: THREE.ImageUtils.loadTexture('images/roomTexture2.jpg')
           }),
           new THREE.MeshLambertMaterial({
               map: THREE.ImageUtils.loadTexture('images/roomTexture2.jpg')
           }),
           new THREE.MeshLambertMaterial({
               map: THREE.ImageUtils.loadTexture('images/roomTexture2.jpg')
           }),
           new THREE.MeshLambertMaterial({
               map: THREE.ImageUtils.loadTexture('images/roomTextureBottom.png')
           }),
           new THREE.MeshLambertMaterial({
               map: THREE.ImageUtils.loadTexture('images/roomTexture2.jpg')
           }),
           new THREE.MeshLambertMaterial({
               map: THREE.ImageUtils.loadTexture('images/roomTexture2.jpg')
           })
        ];
        //var skyTexture = THREE.ImageUtils.loadTexture("images/roomTexture2.jpg");
        
        skyboxMesh = new Physijs.Mesh(new THREE.BoxGeometry(200,200,200), new THREE.MeshFaceMaterial(materials));
        skyboxMesh.scale.x = -1;
        skyboxMesh.emissive = new THREE.Color(0x404040);
        scene.add(skyboxMesh);
    }

    function getNewRotation() {

        if(keyboard.pressed('a')) {
            xrotation += .01;
        }
        if(keyboard.pressed('d')) {
            xrotation -= .01;
        }
        if(keyboard.pressed('w')) {
            yposition += 1;
        }
        if(keyboard.pressed('s')) {
            if(yposition > 1) yposition -= 1;
        }

        camera.position.x = 0 + radius * Math.cos( xrotation );         
        camera.position.z = 0 + radius * Math.sin( xrotation );
        camera.position.y = yposition;
        camera.lookAt( new THREE.Vector3( 0,7,0 ));

    }
    
    createTower = (function() {
        curState = 'play';
       
        blocks = [];
        var block_length = 6, block_height = 1, block_width = 1.5, block_offset = 2,
            block_geometry = new THREE.BoxGeometry( block_length, block_height, block_width );
        
        return function() {
            var i, j, rows = 20,
                block;
            curMaxHeight = rows;
            curRotOrder = rows%2;
            for ( i = 0; i < rows; i++ ) {
                for ( j = 0; j < 3; j++ ) {
                    block = new Physijs.BoxMesh( block_geometry, block_material, 50,
                    { friction: .9, /* medium friction */ restitution: .6 /* medium restitution */ } );
                    block.position.y = (block_height / 2) + block_height * i;
                    if ( i % 2 === 0 ) {
                        block.rotOrder = i%2;
                        block.order = j;
                        block.rotation.y = Math.PI / 2; // #TODO: There's a bug somewhere when this is to close to 2
                        block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
                    } else {
                        block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
                    }
                    block.receiveShadow = true;
                    block.castShadow = true;
                    block.name = 'block';
                    scene.add( block );
                    blocks.push( block );
                }
            }
        }
    })();

    function addLayerToTower() {

        var block_length = 6, block_height = 1, block_width = 1.5, block_offset = 2,
            block_geometry = new THREE.BoxGeometry( block_length, block_height, block_width );
        
        for ( var j = 0; j < 3; j++ ) {
            var block = new Physijs.BoxMesh( block_geometry, block_material, 50,
            { friction: .9, /* medium friction */ restitution: .2 /* medium restitution */ } );
            block.position.y = (block_height / 2) + block_height * (curMaxHeight);
            if ( curRotOrder == 0 ) {
                block.rotOrder = curMaxHeight%2;
                block.order = j;
                block.rotation.y = Math.PI / 2; // #TODO: There's a bug somewhere when this is to close to 2
                block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
            } else {
                block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
            }
            block.receiveShadow = true;
            block.castShadow = true;
            block.name = 'block';
            scene.add( block );
            blocks.push( block );
        }
        curMaxHeight++;
        curRotOrder = (curRotOrder+1)%2;
    }
    
    initEventHandling = (function() {
        var _vector = new THREE.Vector3,
            handleMouseDown, handleMouseMove, handleMouseUp;
        
        handleMouseDown = function( evt ) {
            var ray, intersections;
            
            _vector.set(
                ( evt.clientX / window.innerWidth ) * 2 - 1,
                -( evt.clientY / window.innerHeight ) * 2 + 1,
                1
            );
            _vector.unproject( camera );
            
            ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
            intersections = ray.intersectObjects( blocks );
            if ( intersections.length > 0 ) {
                selected_block = intersections[0].object;
                
                _vector.set( 0, 0, 0 );
                // selected_block.setAngularFactor( _vector );
                selected_block.setAngularVelocity( _vector );
                // selected_block.setLinearFactor( _vector );
                selected_block.setLinearVelocity( _vector );
                mouse_position.copy( intersections[0].point );
                block_offset.subVectors( selected_block.position, mouse_position );
                
                intersect_plane.position.y = mouse_position.y;
            }
        };
        
        handleMouseMove = function( evt ) {
            
            var ray, intersection,
                i, scalar;
            
            if ( selected_block !== null ) {
                
                _vector.set(
                    ( evt.clientX / window.innerWidth ) * 2 - 1,
                    -( evt.clientY / window.innerHeight ) * 2 + 1,
                    1
                );
                _vector.unproject( camera );
                
                ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
                intersection = ray.intersectObject( intersect_plane );
                mouse_position.copy( intersection[0].point );
            }
            
        };
        
        handleMouseUp = function( evt ) {
            
            if ( selected_block !== null ) {
                _vector.set( 1, 1, 1 );
                selected_block.setAngularFactor( _vector );
                selected_block.setLinearFactor( _vector );
                
                selected_block = null;
            }
            
        };
        
        return function() {
            renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
            renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
            renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
        };
    })();
    
    window.onload = initScene;
    
    </script>
</head>

<body style="margin: 0px; padding: 0px;">
    <div id="viewport"></div>
    <div id="p1score" style="position:absolute; top: 10px; left:10px; color:white;"></div>
    <div id="curplayer" style="position:absolute; top: 10px; left: 45%; color:white;"></div>
    <div id="p2score" style="position:absolute; top: 10px; right:10px; color:white;"></div>
    <div id="gameover" style="position:absolute; bottom: 5%; left: 45%; color:red;"></div>

    <!-- Modal -->
    <div class="modal fade" id="myModal" style="background: rgba(0, 0, 0, 0.5);" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
      <div class="modal-dialog" style="background: rgba(0, 0, 0, 0.5);" role="document">
        <div class="modal-content" style="background: rgba(0, 0, 0, 0.5);">
          <div class="modal-header" style="background: rgba(0, 0, 0, 0.5);">
            <button type="button" class="close" style="background: rgba(0, 0, 0, 0.5);" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title" id="myModalLabel">Jenga</h4>
          </div>
          <div style="color:white" class="modal-body">
            <p> Welcome to Jenga v1.0 </p>
            <p> You can either play against the computer or against another human player by choosing your mode below. </p>
            <p> Click and hold down the mouse on a block to select it, and then you may move the block in the XZ plane to try and score.</p>
            <p> The game ends when somebody knocks more than one block off the tower during their turn. </p>
          </div>
          <div class="modal-footer">
            <button type="button" style="left: 10%; right: 80%;" onclick="ai=true" class="btn btn-default" data-dismiss="modal">Computer</button>
            <button type="button" style="right: 10%; left: 80%;" onclick="ai=false" class="btn btn-default" data-dismiss="modal">Two Player</button>
          </div>
        </div>
      </div>
    </div>
</body>

</html>